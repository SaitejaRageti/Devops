**What is RBAC in Kubernetes?**

RBAC (Role-Based Access Control) is a way to control who can do what in your Kubernetes cluster.
It uses the following objects:

Role ‚Äì Defines a set of permissions within a namespace (e.g., can list pods in dev namespace).

RoleBinding ‚Äì Grants a user/service account/group the permissions defined in a Role (in a namespace).

ClusterRole ‚Äì Like Role, but applies cluster-wide (all namespaces).

ClusterRoleBinding ‚Äì Grants a user/service account/group a ClusterRole (cluster-wide).


**üèó How it Works in EKS (AWS)**

In Amazon EKS, authentication is handled through AWS IAM and the aws-auth ConfigMap.

IAM users/roles get mapped to Kubernetes users/groups.

RBAC then decides what they can do.

So, the flow is:
IAM User/Role ‚Üí aws-auth ConfigMap ‚Üí Kubernetes RBAC (Role/ClusterRole + Binding)




**üõ† Process to Add User saiteja in EKS and Bind Roles**

1. Create IAM User in AWS Console

--- >> Go to AWS Console ‚Üí IAM ‚Üí Users ‚Üí Add User.

     creating user ->Name: saiteja.

    Access type: enable Programmatic access (so he can use aws configure).

Attach some basic IAM policies (e.g., AmazonEKSClusterPolicy if he needs to connect).
(Optional: keep minimal policies; access is actually controlled via RBAC once mapped).

Save Access Key + Secret Key for saiteja.

````

2. Map User to Kubernetes (aws-auth ConfigMap)

  By default, IAM users dont directly get kuberenetes permissions.You need to add them to aws-auth ConfigMap in the cluster.

      1. Edit the aws-auth ConfigMap:

               command--> kubectl edit configmap aws-auth -n kube-system
      2. Add the user-Saiteja 
            
                    mapUsers: |
                        - userarn: arn:aws:iam::<ACCOUNT_ID>:user/saiteja
                          username: saiteja
                          groups:
                            - saiteja-group
                    
                    if group not required --exclude the group

                    ‚ö†Ô∏è Replace <ACCOUNT_ID> with your AWS Account ID.

      3. kubectl apply -f aws-auth.yaml


**The step ‚Äúmap IAM user to Kubernetes RBAC‚Äù using the aws-auth ConfigMap is the bridge between AWS IAM and Kubernetes RBAC.**


<!-- So:
üëâ IAM = who are you?
üëâ RBAC = what can you do?
üëâ aws-auth = glue that connects IAM identity to Kubernetes user/group -->


**# 1. Namespace Role (read-only pods in dev namespace)**

apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: dev
  name: dev-pod-reader
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
---
# 2. RoleBinding for saiteja (namespace-level)

apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: dev-pod-reader-binding
  namespace: dev
subjects:
- kind: Group
  name: saiteja-group   # group defined in aws-auth
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: dev-pod-reader
  apiGroup: rbac.authorization.k8s.io
---
# 3. ClusterRole (cluster-wide read-only for pods, nodes, services)

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cluster-readonly
rules:
- apiGroups: [""]
  resources: ["pods", "nodes", "services"]
  verbs: ["get", "list", "watch"]
---

# 4. ClusterRoleBinding for saiteja (cluster-level)
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: cluster-readonly-binding
subjects:
- kind: Group
  name: saiteja-group   # group defined in aws-auth
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: cluster-readonly
  apiGroup: rbac.authorization.k8s.io

